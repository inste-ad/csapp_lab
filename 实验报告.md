[TOC]

# 1.环境配置
使用linux,而且handout压缩包必须在linux环境下解压,在Windows环境下解压并不能运行.
# 2.实验解答
## 1.`bitAnd`的实现

较为简单,用题目给的例子来理解即可
```
bitAnd(6, 5) = 4
x = 6;// 110
y = 5;// 101
~x = 001;
~y = 010;
tmp = (~x) | (~y)  = 011;
~tmp = 100 = 4;
```
所以代码如下
```
int bitAnd(int x, int y) {
    return ~((~x)|(~y));
}
```
## 2.`getByte`的实现
__要特别注意小端法,大端法,以及左移右移的关系__


如上图所示, 在小端法里面,csapp书上是以第二种方式来呈现的, 我一开始以为右移是根据`0x78563412`这个顺序来的, 其实并不然, 右移应该是按照数字的顺序来, 即`0x1234578`这样, 而实际上也就是第三行中的小端表示法, 而且我看在i386的用户手册上面, 也是把小地址放右端, 大地址放左端来表示小端法

将所需要数字右移之后, 再用掩码`0xff`取最后一个字节即可得到答案

所以代码如下
```
int getByte(int x, int n) {
    int result = x >> ((n) << 3);
    return result & 0xff;

}
```
## 3.`logicalShift`的实现
__以下假设n是4, 且位数只有8位__
在机器中, 默认的右移是逻辑右移, 所以`1000 0000`右移之后是`1111 1000`, 即`x >> n`
而我们需要的是`0000 1000`, 所以我们需要一个标尺, 用以和`x >> n`之后做位运算, 而且要明确满足以下条件:
* 右移产生的部分要保持是0
* 原来的部分要保持原来的样子

那么自然而然的, 对于上面的例子来说标尺应该是`0000 1111`

那么`0000 1111`怎么产生呢?
1. 由`1000 0000`右移产生`1111 1000`
2. 然后取反得到`0000 01111`
3. 左移一位再加1, 得到`0000 1111`

根据上面所说的, 将这个标尺与`x >> n`进行_按位与_运算即可, 由上面的叙述, 可以得到32位, 右移n位时的代码
```
int logicalShift(int x, int n) {
    return (x >> n) & (((~(1 << 31) >> n) << 1)+ 1); // there must be a () befor '+'
}
```
唯一要注意的是, `+`的优先级大于`>>`和`<<`, 所以要记得加括号, 否则会出错.
## 4.`bitCount`的实现
这里要计算的是数字的二进制表示法中数字`1`的个数, 在这里可以用 __二分法__ 来实现
```
So if I have number 395 in binary 0000000110001011 (0 0 0 0 0 0 0 1 1 0 0 0 1 0 1 1)
After the first step I have:      0000000101000110 (0+0 0+0 0+0 0+1 1+0 0+0 1+0 1+1) = 00 00 00 01 01 00 01 10
In the second step I have:        0000000100010011 ( 00+00  00+01  01+00  01+10 ) = 0000 0001 0001 0011
In the fourth step I have:        0000000100000100 (  0000+0001      0001+0011  ) = 00000001 00000100
In the last step I have:          0000000000000101 (      00000001+00000100      ) = 5
```
从上面的例子可以看出来, 将一串01数字两两分组算出每一个的和之后, 再四个四个一组算出每一组中1的个数, 一直算到出结果为止.

那么具体怎么实现两两分组甚至之后的四四分组呢?
我们可以用`0x5555555(01010101010101010101010101010101)`来作为掩码, 计算偶数位的(0, 2, 4..)的`1`的个数, 然后再将所计算的数右移一位, 即可计算奇数位的`1`的个数
又由于在题目的要求中, 不可以使用大于`0xff`的数, 所以在程序中`0x55555555`可以用`0x55 | (0x55 << 8)`来表示

算出来之后得到每两个一组的`1`的个数, 之后就可以利用掩码`0011 0011 0011 0011 0011 0011 0011 0011`来计算偶数位的`1`的个数(注意, 这里要将2位当作一个整体). 计算出来之后, 将x右移两位, 按照上述方法计算. 即可得到每四个分组的`1`的个数

同理, 可以一直这样计算到每16个分组, 直到每32个分组. 也就是得到了答案.

以下是实现代码
```
int bitCount(int x) {
    int mask1 = 0x55 | (0x55 << 8);
    int mask2 = 0x33 | (0x33 << 8);
    int mask3 = 0xf | (0xf << 8);
    int mask4 = 0xff | (0xff << 16);
    int mask5 = 0xff | (0xff << 8);
    int count;
    mask1 = mask1 | (mask1 << 16);
    mask2 = mask2 | (mask2 << 16);
    mask3 = mask3 | (mask3 << 16);
    count = (x & mask1) +((x >> 1) & mask1); 
    count = (count & mask2) + ((count >> 2) &mask2);
    count = (count & mask3) + ((count >> 4) & mask3);
    count = (count & mask4) + ((count >> 8) & mask4);
    count = (count & mask5) + ((count >> 16) & mask5);
    return count;
}
```
## 5.`bang`的实现
先对`x`取负数`(~x) + 1`, 然后再和`x`作或运算, 那么:
1.若`x == 0`, 即
```
x = 0x00000000
(~x + 1) = 0x0000000
tmp = x | (~x + 1) = 0x0000000
tmp >> 31 = 0x0000000
tmp + 1 = 1
```
所以会返回`1`
2.若`x != 0`, 假设`x=0x8000000`(特殊情况), 即
```
x = 0x8000000
(~x + 1) = 0x800000
tm = x | (~x + 1) = 1
tmp >> 31 = 0xFFFFFFFF
tmp + 1 = 0
```
一般情况下, 假设`x=0x700000000`, 即
```
tmp = x |  (~x + 1) = 1
(tmp >> 31) + 1 = 0
```
返回`0`
代码如下
```
int bang(int x) {
    return ((((~x) + 1) | x) >> 31) + 1;
}
```
## 6.`tmin`的实现
由补码的规则可以知道`0x80000000`补码能标示的最小数字(32位)
所以代码如下
```
int tmin(void) {
    return 1 << 31;
}
```
## 7.`fitsBits`的实现
题目的意思是给定一个数`x`和一个规定量`n`, 问是否能用`n`个比特的补码形式来表示`x`
在例子中`5`的二进制表示是`101`, 但是只用3个比特来表示是不可能的, 因为补码的最高位是符号位, 所以至少需要4个比特才可以表示`5`
那么用程序语言如何表达呢
只要将`x`左移`32-n`, 再右移回去, 观察和原来是否一样(用异或实现), 如果不一样的话, 就说明有一个在`n`位的限制下, 最高位有一个`1`, 而这个`1`要用来当作符号位的.
代码如下
```
int fitsBits(int x, int n) {
    int shiftTimes = (~n) + 1 + 32;
    int tmp = (x << shiftTimes) >> shiftTimes;
    return !(x ^ tmp);
}
```
## 8.`divpwr2`的实现
在csapp p73-p74有描述, `x/(2^k)`的c语言表达式是`(x < 0 ? x + (1 << k) - 1: x) >> k`(算数右移), 也就是说若`x < 0`那么, 就需要加上偏置量`(1 << k) - 1`
但是题目要求不可以用`if`这类的语句, 如何判断`x`是大于0还是小于0呢?
首先, 先获得`x`的符号`sign = x >> 31`, 如果 `x`小于0, `sign`等于`0xffffffff`, 否则`sign = 0`
然后计算偏置量, `bias = sign & ((1 << n) + (~0))`, 其中`~0 = -1`, 在这个表达式中, 若`x`小于0, 那么计算的偏置量得以保留, 如果`x`大于0, 那么x的偏置量为0
代码如下
```
int divpwr2(int x, int n) {
    int sign = x >> 31; // if x < 0 , sign = 0xffffffff, else sign = 0;
    int bias = sign & ((1 << n) + (~0));
    x = x + bias;
    return x >> n;
}
```
## 9.`negate`的实现
返回一个数的负数, 很简单, 代码如下
```
int negate(int x) {
    return (~x) + 1;
```
## 10.`isPositive`的实现
对于0和正数来说符号位都是0, 负数的符号位是1, 看起来0和正数作为一组比较合适, 而负数作为一组比较合适. 
但是题目要求0和负数返回1, 而正数返回0
那么我们先求出取出`x`的符号位
```
x >> 31
```
然后与`!x`做或运算, 那么
1.若`x`小于0, 则`!x = 0`, 而`x >> 31 = 0xffffffff`, 做或运算是得到一个非0的值, 再取反就可以得到返回值`0`
2.若`x`大于0, 则`!x =0`, 而`x >> 31 = 0x0`, 做或运算得到0值, 再取反就得到返回值`1`
3.若`x`等于0, 则`!x = 1`, 而`x >> 31 = 0x0`, 做或运算得到非0值, 再取反就得到返回值`0`
代码如下
```
int isPositive(int x) {
    return !((x >> 31) | (!x));
```
## 11.`isLessOrEqual`的实现
要判断`x <= y`也就是判断`y - x >= 0`是否实现, 但是对于有符号数来说, 这样直接相减是有可能溢出的, 比如`x=127, y=-128`
但是我们可以基于以下原则做判断
1.若`x`和`y`同号, 那么不会有溢出的情况
2.若二者异号, `y - x >= 0`的真值判断与y的符号位相反, 比如`y`小于0, 那么符号位就是1, 而该表达式明显是假的,则返回!signY
代码如下
```
int isLessOrEqual(int x, int y) {
    int signX = !!(x >> 31); //取x的符号位
    int signY = !!(y >> 31); //取y的符号位
    int z = y + ((~x) + 1); // z = y - x
    int signZ = !!(z >> 31); // 取z 的符号位
    return ((!(signX ^ signY)) & (!signZ)) | ((signX ^ signY) & (!signY));  
    // | 的前半部分意思是若signX等于signY, 也就是同号, 那么真假就取决于signZ也就是y-x的
    //符号位, 若Z小于零, 那么y-x>=0不成立, 应该返回0, 也就是!signZ.
    //若x, y同号, 那么前半部分值肯定是1, 后半部分就不用看了, 总的来说肯定返回1
    // | 的后半部分的意思是若signX不等于signY, 也就是异号, 前半部分就是0, 表达式的真假
    // 取决于后半部分, 而后半部分的意思就是异号时看y的符号位
}
```
## 12.`ilog2`的实现
这个函数本质就是要找最高位的1在那个位置, 那么就用二分法就可以了
就是先判断第一个1是否在前16位, 用`!!(x >> 16)`表示, 如果在, 那么这个表达式就等于1, 如果不是这个表达式就等于0.如果在的话tmp就会加上16, 然后在前16个位中找最高位, 如果不是的话就在后16位的中找最高位.
怎么实现上述说法呢, 下一条语句就是了`x >> (tmp + 8)`也就是说, 如果刚才在前16位找到了第一个1, 那么tmp就等于24, 那么就在前16位中的前8位中看看有没有1的存在, 否则就是在后16位中的前8位寻找有没有1的存在
以此类推
代码如下
```
int ilog2(int x) {
    int tmp;
    tmp = (!!(x >> 16)) << 4;
    tmp = tmp + ((!!(x >> (tmp + 8))) << 3);
    tmp = tmp + ((!!(x >> (tmp + 4))) << 2);
    tmp = tmp + ((!!(x >> (tmp + 2))) << 1);
    tmp = tmp + ((!!(x >> (tmp + 1))) << 0); 
    return tmp;
}
```
## 13.`float_neg`的实现
本题要实现浮点数的负数, 那么
1.若给的uf是NaN那么, 应该是前2-9位全是1, 以及后23位全是0(此处可参考csappP78), 并直接返回uf
2.若不是NaN那么就将符号位取反就可以了

所以实现代码如下
```
unsigned float_neg(unsigned uf) {
    if (!(((uf >> 23) & 0xff) ^ 0xff) && (uf << 9)) {
        return uf;
    } else {
        return uf += (1 << 31);
    }
}
```
## 14.`float_i2f`的实现
本题是将浮点数转化为整数, 在csapp P82有阐述, 但是书上只有说到如何从正数转换, 并没有说0和负数怎么转换.
1.对于0, 其实不用转换, 直接返回0就可以了
2.对于负数, 将负数转换为正数即可, 只要最后再处理符号位就可以了, 但是要注意一种情况, 就是Tmin的情况, 当负数取得补码能表示的最小值时, 取负数还是他自己, 那么这个时候直接返回一个特殊值就可以了, 毕竟特殊情况特殊处理

根据书上的教程, 要先找到第一个1的位置, 因为实验要求, 在这里可以使用`for`或者`while`之类的语句, 比较方便,可以算出fraction尾数.而exp也很好算, 不过要注意对frac进行舍去的时候遵守四舍六入五随偶的原则, 具体实现可以看代码
```
unsigned float_i2f(int x) {
// there is a method in csapp page 82
    unsigned s = x & (1 << 31);
    int pos = 30;
    int frac_mask = (1 << 23) - 1;
    int frac, exp;
    int delta;
    if (!x) {
        return x;
    }
    if (x == 0x80000000) {
        return 0xcf000000;
    }
    if (x < 0) {
        x = -x;
    }
    while (!(x >> pos)) {
        pos--;
    }
    exp = pos + 127;
    x = x << (31 - pos);
    frac = (x >> 8) & frac_mask; 
    x = x & 0xff;
    delta = (x > 128) || ((x == 128) && (frac & 1));
    frac += delta;
    if (frac >> 23) {
        frac = frac & frac_mask;
        exp++;
    }
    return s | (exp << 23) | frac; 
}
```
## 15.`float_twice`的实现
本题要实现浮点数乘以2
1.若阶码等于255, 那么就说明是NaN, 直接返回就可以了(代码中的处理是在`if`之中)
2.当阶码不等于255的时候, 说明`uf`是一个数, 那么就可以分别取得该浮点数的符号位`s`, 阶码`exp`和尾数`frac`
    * 若`exp == 0`, 那么直接将尾数左移1位就可以了
    * 若`exp != 0`, 那么将阶码`exp`加1就可以了, 要注意当`exp == 0xff`时, 也就是阶码8位全是1, 这时候就要将尾数`frac`清零, 作为无穷大返回

具体代码实现如下
```
unsigned float_twice(unsigned uf) {
    unsigned s = uf & (1 << 31);
    int exp = (uf >> 23) & 0xff;
    int frac = uf & 0x7fffff;
    if (exp !=  0xff) {
        if (!exp) {
            frac <<= 1;
        } else {
            exp++;
            if (exp == 0xff) {
                frac = 0;
            }
        }
    }
    return s | (exp << 23) | frac;
}
```
# 3.感想与体会
 为了写这个报告，查了很多资料。在源码中有某些自己的想法，和查的资料不一样，但思想类似。就怎么都调不通。才发现有很多问题，边界溢出，正负补码问题，还有浮点数的舍入问题。 对这些看书的时候没有太认真的问题理解的很深刻了。
